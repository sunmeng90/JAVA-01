学习笔记
## 第一节：

### 总结

* Java平台独立是指字节码平台独立，通过各个平台独立的jvm实现  
* JVM语言执行流程： JVM类语言编码 -> 字节码 -> 加载到JVM -> 解释/即时编译执行  
* 字节码结构：元信息(versinon, md5，文件名等)、常量池（字面量、符号引用）、方法（方法签名、指令序列、局部变量表、操作数栈、异常表）
* 字节码：用一个字节表示指令，最大256个指令. 包括控制指令(goto，ifxxx等), 运算指令（加减乘除，位操作，比较，自增），栈操作指令，类型转换、对象创建及访问(数组及对象)、方法调用及返回、异常处理、同步。
* 加载：字节码有类加载器载入虚拟机内存。传统加载方法使用流双亲委派模式，将类加载工作委托给父类执行，保证Java核心类的唯一性和安全。JDK9之后由于模块化应用，导致类加载复杂，因此加载方法有变化。
* 双亲委派加载中类加载优先级：启动类加载器（rt.jar) > 扩展类加载器(ext/xx.jar) > 系统类加载器(claspath) > 用户自定义加载器(从特定位置读取字节流、解密字节流等操作)
* 运行时数据区： 堆、栈、PC计数器、本地方法栈、方法区
* jvm启动参数：用于配置JVM内存分配、及垃圾收集行为等等，常用：-Xmx, -Xms, -Xss, -XX:+UsexxxGC, -XX:+PrintGCDetails 等等

### 作业

* GCLogAnalysis.java
* ClasspathClassLoader.java
* Java Runtime Area.pptx

## 第二节

* JDK工具主要用于观察和分析系统运行时行为包括：jmap（对象内存分配）、jstat（gc)、jstack(线程)、jps（进程号）、jcmd（综合前集中功能）； 此外还有提供相同功能的集成图形化工具： jconsole, jvisualvm, jmc
* 垃圾标记基本原理包括
  * 引用计数：循环依赖不叫难解决
  * 可达性分析：jvm 使用，根据程序运行时栈局部变量等及类静态变量为起始点依次查找依赖链，然后清除所有不在依赖链上的对象

* 垃圾清除原理：
  * 标记清除：直接清除垃圾对象，容易产生内存碎片（下次内存分配很可能失败导致再次gc)
  * 标记复制：复制可用对象到新的内存区域，适合生命周期短的对象。缺点是要额外的内存区域用于复制对象
  * 标记整理：将可用对象向内存地址一端移动

* 基于工程实践发现程序运行时大部分对象（90%）都属于声明周期短的对象，因此应该根据其生命周期特点分而治之，提高收集效率。目前jvm内存管理多数仍基于对象声明周期长短而划分出分代管理的理念。
  * 年轻代，因为存活率较低因此适合复制算法
  * 老年代，存货率较高因此适合清理、整理算法

* jvm在垃圾收集时必须要达到引用一致性，因此在标记GC roots时要暂停所有线程（STW）防止引用关系变化， STW 时系统不会响应任何业务，因此要尽量缩短STW时间

* 为了充分利用CPU多核提高垃圾收集效率，因此可以多线程并行垃圾收集，但此刻业务线程仍暂停，但整体垃圾收集时间相对于单线程变短

* 因为垃圾收集都是以GC root为起点查找，因此当所有线程暂停，找到所有GC roots后后续引用链遍历并不需要暂停线程，所以遍历操作可以和业务线程一起运行，而不用STW，这就是并发收集器，后续引用链查找和垃圾清理和用户线程并发运行

* 传统基于分代收集的垃圾收集器，每次都要对整个区（eden或old）扫描收集，不管程序需要多少空闲内存，一种更有效率成本更小的思想时每次不对整个区块收集，而是只要收集释放的速率大于程序需要分配的速率即可。因此我们把内存划分成更小的区块（2048），每个小区块动态用作yong/old区，每个区块同时记录有自己内存使用情况的统计信息，这样在垃圾收集是可以根据每个区块的统计信息计算出垃圾收集的成本和收益，并排序，优先对收集效率更高的区块收集，而不是对所有区块收集。这样一个基于优先级有选择的收集的模型对STW的时间有更好的控制。这种垃圾收集器因为要记录每个小区块的统计信息，所有有比较高的内存空间成本。

* 垃圾收集器：
  * Serial： 单线程
  * Parallel：多线程并行，吞吐量优先，JDK8 默认
  * CMS：并发，主要目标时缩减old区STW时间，响应优先
  * G1：与CMS相似，垃圾优先。将 STW 停顿的时间和分布，变成可预期且可配置的
  * ZGC、Shenandoah： 实现 GC Pauseless（10ms)，并且与堆大小无关

* 垃圾收集器选择：
  * 一般应用默认即可：ParallelGC，吞吐量优先
  * 如果有明确要求低延迟，选用CMS
  * 如果堆大小大于8G，可选用G1
  
### 作业

* 第 2 节课作业实践.docx